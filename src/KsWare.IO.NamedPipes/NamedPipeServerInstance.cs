// ***********************************************************************
// Assembly         : KsWare.IO.NamedPipes
// Author           : SchreinerK
// Created          : 02-02-2018
//
// Last Modified By : SchreinerK
// Last Modified On : 02-05-2018
// ***********************************************************************
// <copyright file="NamedPipeServerInstance.cs" company="KsWare">
//     Copyright © 2018 by KsWare. All rights reserved.
// </copyright>
// <summary></summary>
// ***********************************************************************
using System;
using System.Diagnostics;
using System.IO;
using System.IO.Pipes;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using KsWare.IO.NamedPipes.Internal;

namespace KsWare.IO.NamedPipes {

	/// <summary>
	/// Class NamedPipeServerInstance.
	/// </summary>
	/// <seealso cref="System.IDisposable" />
	/// <autogeneratedoc />
	public class NamedPipeServerInstance : IDisposable {

		private static int _lastInstanceId;

		private readonly NamedPipeServerStreams _streams;
		private bool _disposeFlag = false;


		/// <summary>
		/// Initializes a new instance of the <see cref="NamedPipeServerInstance"/> class.
		/// </summary>
		/// <param name="pipeName">Name of the pipe.</param>
		/// <param name="maxNumberOfServerInstances">The maximum number of server instances.</param>
		/// <autogeneratedoc />
		public NamedPipeServerInstance(string pipeName, int maxNumberOfServerInstances) {
			_streams = new NamedPipeServerStreams(
				pipeName,
				PipeDirection.InOut, 
				maxNumberOfServerInstances,
				PipeTransmissionMode.Byte, 
				PipeOptions.None
			);
		}

		/// <summary>
		/// Gets the task.
		/// </summary>
		/// <value>The task.</value>
		/// <autogeneratedoc />
		public Task Task { get; private set; }

		/// <summary>
		/// Gets the instance identifier.
		/// </summary>
		/// <value>The instance identifier.</value>
		/// <autogeneratedoc />
		public int InstanceId { get; } = Interlocked.Increment(ref _lastInstanceId);

		/// <summary>
		/// Occurs when connected.
		/// </summary>
		public event EventHandler Connected = delegate { };

		/// <summary>
		/// Occurs when disconnected.
		/// </summary>
		public event EventHandler Disconnected = delegate { };

		/// <summary>
		/// Occurs when request received.
		/// </summary>
		public event EventHandler<PipeMsgEventArgs> RequestReceived = delegate { };

		/// <summary>
		/// Starts this instance.
		/// </summary>
		/// <autogeneratedoc />
		public void Start() {
			Task = Task.Factory.StartNew(Communication);
//			if(_thread!=null) throw new InvalidOperationException("Already started.");
//			_thread = new Thread(Communication);
//			_thread.Start();
		}

		/// <summary>
		/// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
		/// </summary>
		/// <autogeneratedoc />
		public void Dispose() {
			_disposeFlag = true;
			_streams.Dispose();
		}

		private void Communication() {
			string exitReason = "None";
			try {
				Debug.WriteLine($"[Server {InstanceId}] Communication Started");
				if (!_streams.WaitForConnectionCancelable()) { exitReason = "Connect canceled";return;}
				Debug.WriteLine($"[Server {InstanceId}] Communication Connected");
				Connected?.Invoke(this, EventArgs.Empty);

				while (true) {
					if(_disposeFlag) { exitReason = "Disposed"; break; }
					if (_streams.Reader.EndOfStream) { exitReason = "EndOfStream"; break;}

					var request = _streams.Reader.ReadLine(); // TODO read strategy message/byte/line
					Debug.WriteLine($"[Server {InstanceId}] Communication Received");

					if (request != null) {
						var msgEventArgs = new PipeMsgEventArgs(request);
						RequestReceived.Invoke(this, msgEventArgs);
						_streams.Writer.WriteLine(msgEventArgs.Response);
						_streams.Writer.Flush();
					}
				}
			}
			catch (IOException ex) {
				exitReason = "IOException";
				Debug.WriteLine(ex);
			}
			catch (Exception ex) {
				exitReason = "Exeption";
				Debug.WriteLine(ex);
			}
			finally {
				Debug.WriteLine($"[Server {InstanceId}] Communication exit. Reason: {exitReason}");
				Disconnected?.Invoke(this,EventArgs.Empty);
				Dispose();
			}
		}
	}
}


